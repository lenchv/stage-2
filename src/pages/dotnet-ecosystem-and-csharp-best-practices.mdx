import { Lecture, Message, TimelineOfContents, Level, ThatsAllFolks } from "../components";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faFacebookSquare, faGithub, faLinkedin, faSkype } from "@fortawesome/free-brands-svg-icons";
import rostyslavDiakivAvatar from "../assets/avatars/rostyslav-diakiv-2019.svg";
import aEtoMagazin from "../assets/images/a-eto-magazin.png";
import './dotnet-ecosystem.css';

<div><h1><strong>.NET ecosystem and C# best practices</strong></h1></div>

<div>
  <div class="author">
    <div id="avatar-wrapper">
      <object id="avatar" data={rostyslavDiakivAvatar} role="img" aria-label="My profile picture"></object>
    </div>
    <div class="profile">
      <h3 class="name">Ростислав Дяків</h3>
      <ul class="contacts">
        <li>
          <a href="https://www.facebook.com/rostislav.dyakiv" rel="author" class="facebook">
            <FontAwesomeIcon icon={faFacebookSquare} className="icon" />
            <span>rostislav.dyakiv</span>
          </a>
        </li>
        <li>
          <a href="https://github.com/rostyslav-diakiv" rel="author" class="github">
            <FontAwesomeIcon icon={faGithub} className="icon" />
            <span>rostyslav-diakiv</span>
          </a>
        </li>
        <li>
          <a href="https://www.linkedin.com/in/rostyslav-diakiv/" rel="author" class="linkedin">
            <FontAwesomeIcon icon={faLinkedin} className="icon" />
            <span>rostyslav-diakiv</span>
          </a>
        </li>
        <li>
          <a href="skype:rostik8803" rel="author" class="skype">
            <FontAwesomeIcon icon={faSkype} className="icon" />
            <span>rostik8803</span>
          </a>
        </li>
      </ul>
      <p class="about">
        Володя працює фулл-стек розробником у <a href="https://binary-studio.com"><strong>Binary Studio</strong></a> вже 2 роки, де будує точні, адаптивні, швидкі, зручні в користуванні середовища, які гарно виглядають та добре виконують свої завдання. Улюбленими технологіями вважає <a href="#"><strong>React</strong></a> та <a href="#"><strong>GraphQL</strong></a>. Говорить російською із смішним акцентом.
      </p>
    </div>
  </div>
  <div class="bubble" style="margin: -0.5em 1em 1em;">
    <strong class="dorov">Доров.</strong>
    <span class="tooltip" data-tooltip="А это магазин?">
      <img src={aEtoMagazin} class="a-eto-magazin" alt="А это магазин?" />
    </span>
    <br />
    Вже за два абзаци розпочнеться лекція. Але! Спочатку пара коротеньких дісклеймерів: 1) деякі терміни та технології не пояснюються, лінки на документацію та ґайдлайни опціональні <em>(їх можна повністю проігнорувати, маючи сильну інтуїцію, багаж знань чи достатньо часу на експерименти)</em>; 2) лекція намагається бути фановою і максимально корисною, але не завжди так буде виходити в результаті &#x1F937;&#x200D;&#x2642;&#xFE0F; <em>(за бекання-мекання і вживання іншомовних слів пробачте, будь ласка)</em>. Між іншим, it's dangerous to go alone! Take this: <a href="https://git-scm.com/"><strong>Git</strong></a>, <a href="https://desktop.github.com/"><strong>GitHub Desktop</strong></a>, <a href="https://code.visualstudio.com/"><strong>Visual Studio Code</strong></a>
  </div>
</div>

<div id="table-of-contents" class="table-of-contents" style="margin-top: 1.5em;">
  <TimelineOfContents timeline={[{
    linkTo: "#dotnet-platform-overview",
    title: "Огляд .NET платформи"
  }, {
    linkTo: "#dotnet-under-the-hood",
    title: ".NET під катопом"
  }, {
    linkTo: "#csharp-essential-topics",
    title: "Найважливіші поняття C#"
  }, {
    linkTo: "#clean-code-principles",
    title: "Принципи чистого коду"
  }]} />
</div>

<Level id="dotnet-platform-overview" number="1" name="Огляд .NET платформи" difficulty="Мамкин комп'юторщик." objectives="Зрозуміти SDK." labels={{ level: "Розділ", backToTop: "нагору", difficulty: "Складність:", objectives: "Мета:" }} />

<ul>
  <li class="details">
    <input type="checkbox" id="accordion-1-1" />
    <label class="summary" for="accordion-1-1">
      <h5><strong>.NET platform</strong></h5>
    </label>
    <div class="details-body">
      <p>Зараз інфраструктура .NET-y виглядає наступним чином:</p>
      <div class="columns text-center">
        <div class="column col-4">
          <div class="panel">
            <div class="panel-header">
              <strong>.NET framework</strong>
            </div>
            <div class="panel-body">
              <div class="columns">
                <div class="column col-2">WPF</div>
                <div class="column col-7">Windows Forms</div>
                <div class="column col-3">ASP.NET</div>
              </div>
            </div>
          </div>
        </div>
        <div class="column col-4">
          <div class="panel">
            <div class="panel-header">
              <strong>.NET Core</strong>
            </div>
            <div class="panel-body">
              <div class="columns">
                <div class="column col-6">UWP</div>
                <div class="column col-6">ASP.NET Core</div>
              </div>
            </div>
          </div>
        </div>
        <div class="column col-4">
          <div class="panel">
            <div class="panel-header">
              <strong>Xamarin</strong>
            </div>
            <div class="panel-body">
              <div class="columns">
                <div class="column col-4">iOS</div>
                <div class="column col-4">Android</div>
              </div>
            </div>
          </div>
        </div>
        <div class="column col-12">
          <div class="panel">
            <div class="panel-header">
              <strong>.NET Standard Library</strong>
            </div>
          </div>
        </div>
        <div class="column col-12">
          <div class="panel">
            <div class="panel-header">
              <strong>Common infrastructure</strong>
            </div>
            <div class="panel-body">
              <div class="columns">
                <div class="column col-4">Compilers</div>
                <div class="column col-4">Languages</div>
                <div class="column col-4">Runtime components</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <p>Шляхи створення .NET-додатків:</p>
      <ol>
        <li>.NET Framework - розробка під Windows. Настільні додатки на Windows Forms, WPF. Веб-сервери на ASP.NET та WCF</li>
        <li>.NET Core - розробка крос-платформних веб-додатків за допомогою framework ASP.NET Core. Створення гібридних додатків з допомогою UWP- Universal Windows Platform, яка дозволяє запускати програму написану на цій технології на Windows машині, X-Box, Hololens</li>
        <li>Xamarin - платформа для створення мобільних додатків для IOS i Android, використовуючи C#, XML та XAML</li>
      </ol>
      <p>Код який написаний під спеціальний фреймворк, як WPF, Asp.Net Core чи Android не можна перевикористати на іншій платформі, тому що він заточений для роботи з так званими Platform-specific API який відрізняється у них всіх.</p>
      <p>Для розв'язання цієї проблеми, а саме перевикористання коду бізнес-логіки, хелпер методів, меделей, класів і так далі у іншій платформі створили .Net Standart - який надає набір доступних АPI, що працює на усіх платформах:</p>
      <ul>
        <li>Настільні програми</li>
        <li>Веб-сервери</li>
        <li>Мобільні додатки та ігри</li>
        <li>Хмарні служби</li>
      </ul>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-1-2" />
    <label class="summary" for="accordion-1-2">
      <h5><strong>NuGet</strong></h5>
    </label>
    <div class="details-body">
      <p>Кожному програмісту рано чи пізно гарантовано потрібно імплементовувати функціонал, який частково або повністю хтось раніше вже створив і навіть опублікував (як правило у вигляді DLL бібліотеки). Розробники називають такі модулі "пакетами", в які складено скомпільований код, додаткові файли-ассети та маніфест, що пояснює мету та спосіб використання пакету. У більшості мов програмування є власні платформи для обміну такими корисними модулями, у .NET це <strong>NuGet</strong>, пітримуваний <strong>Microsoft</strong>-ом. Розробники, які створили крутий інструмент чи, наприклад, бібліотеку для роботи з файловою системою, мають можливість опублікувати свою роботу як NuGet-пакет в вигляді zip-файлу з розширенням <strong>.nupkg</strong>. Ви можете шукати та скачувати модулі, які пришвидшать розробку вашого додатку, з центрального репозиторію <strong>NuGet Gallery</strong> ― він налічує вже близько 100000 унікальних пакетів і там може знайтись щось корисне.</p>
    </div>
  </li>
</ul>

<Level id="dotnet-under-the-hood" number="2" name=".NET під капотом" difficulty="Мамкин комп'юторщик." objectives="Зрозуміти SDK." labels={{ level: "Розділ", backToTop: "нагору", difficulty: "Складність:", objectives: "Мета:" }} />

<ul>
  <li class="details">
    <input type="checkbox" id="accordion-2-1" />
    <label class="summary" for="accordion-2-1">
      <h5 style="display: flex; align-items: center;">
        <span style="margin-right: 0.25em;"><strong>CLR</strong></span>
        <small style="font-size: 0.5em; text-transform: uppercase;">
          Common Language Runtime
        </small>
      </h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Сьогодні у `.Net` світі 3 найпоширеніші мови програмування це `C#`, `F#` та `Visual Basic`.
      У кожної є свій компілятор, який перетворює код написаний на цій мові у `IL - Intermediate Language Code`, який представляє з себе набір інструкцій для віртуальної машини `.Net` - `CLR - Common Language Runtime`.
      Основні етапи виконання програми `.Net`:</p>
      <ul>
        <li class="details">
          <input type="checkbox" id="accordion-2-1-1" />
          <label class="summary" for="accordion-2-1-1">
            Спочатку написаний нами код, компілятор перетворить C# у IL:
          </label>
          <div class="details-body" style="margin-bottom: 0.5em;">
            <div class="columns">
              <div class="column col-6">
                Звичайний C# код
<div>

```csharp
public void SumTwoNumbers()
{
    int firstNumber = 10;
    var secondNumber = 200;

    Console.WriteLine(firstNumber + secondNumber);
}
```

</div>
              </div>
              <div class="column col-6">
                C# код скомпільований в IL
<div>

```csharp
.method public hidebysig 
	instance void SumTwoNumbers () cil managed 
{
	// Method begins at RVA 0x2070
	// Code size 18 (0x12)
	.maxstack 2
	.locals init (
		[0] int32 firstNumber,
		[1] int32 secondNumber
	)

	IL_0000: ldc.i4.s 10
	IL_0002: stloc.0
	IL_0003: ldc.i4 200
	IL_0008: stloc.1
	IL_0009: ldloc.0
	IL_000a: ldloc.1
	IL_000b: add
	IL_000c: call void [mscorlib]System.Console::WriteLine(int32)
	IL_0011: ret
}
```

</div>
              </div>
            </div>
          </div>
        </li>
        <li>Тоді, коли прийде час для виконання частини нашого коду в програмі - `CLR` за допомогою JIT - Just in Time компілятора перетворить код `IL` на `машинний код`.</li>
      </ul>
      <p>Результатом білда `.Net` програми є файл з розширенням `.exe` - executable файл, або: `dll` - `Dynamic Link Library`.</p>
      <div class="bubble small subtle">
        Важливо зазначити, що перетворення `IL` в `машинний код` відбувається лише тоді коли потрібно, тобто буде перетворена тільки та частина коду, яка має виконатись в теперішній момент часу.
      </div>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-2-2" />
    <label class="summary" for="accordion-2-2">
      <h5><strong>Value and Reference types</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>На найвищому рівні у `С#` є 2 типи даних - це значимі типи(`value types`) і ссилочні типи (`reference types`). Важливо розуміти відмінності між ними:</p>
      <div class="columns">
        <div class="column col-6">
          До значимих типів у <strong>.NET</strong> відносяться:
          <ul>
            <li>Целочисленні типи</li>
            <li>Типи з плаваючою крапкою</li>
            <li>`decimal`</li>
            <li>`bool`</li>
            <li>`enum`-и</li>
            <li>`структури`</li>
          </ul>
        </div>
        <div class="column col-6">
          До `Ссилочних`:
          <ul>
            <li>тип `object`</li>
            <li>`string`</li>
            <li>`класи`</li>
            <li>`інтерфейси`</li>
            <li> та `делегати`</li>
          </ul>
        </div>
      </div>
      <p>Значимі типи зберігаються у стеку, Ссилочні на кучі. `Value types` передаються по значенню, тобто копіюютья, `reference types` - передаюься по ссилці. Далі ми розглянемо що це означає</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-2-3" />
    <label class="summary" for="accordion-2-3">
      <h5><strong>Stack and Heap</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>У <strong>.NET</strong>-і пам'ять ділиться на два типи: на `стек` і `кучу`
      `Стек` являє собою структуру даних, яка росте знизу вгору: кожен новий елемент, поміщається поверх попереднього.
      У стеку зберігаються `Значимі типи` та посилання на `Ссилочні типи`, що у свою чергу розміщуться на `кучі`
      `Кучу` можна уявити як невпорядкований набір різнорідних об'єктів.
      При створенні об'єкту `Ссилочного типу` в `стек` додається посилання на адресу цього об'єкту на `кучі`.
      Коли об'єкт `Ссилочного типу` перестає використовуватися, то посилання з стеку видаляється, і пам'ять звільняється.
      У .NET-і очищення пам'яті відбувається автоматично. За це відповідає - зборщик мусору - `Garbage Collector`. Коли він бачить, що на об'єкт в кучі більше немає посилань, видаляє цей об'єкт та очищує пам'ять.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-2-4" />
    <label class="summary" for="accordion-2-4">
      <h5><strong>ref, out parameters</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Важливий момент у тому, як змінні `Значимих` та `Ссилочних` типів передаються у метод.</p>
      <div class="columns">
        <div class="column col-6">
<div>

```csharp
static void Main(string[] args)
{
    int c = 20;
    
    MethodValue(c);
    
    Console.WriteLine(c); // 20
}

// pass copy of the value
static void MethodValue(int variableCopy)
{
    variableCopy = 1;
}
```

</div>
        </div>
        <div class="column col-6">
<div>

```csharp
static void Main(string[] args)
{
    int d = 30;
            
    MethodValueRef(ref d);

    Console.WriteLine(d); // 2
}

// pass value by reference 
static void MethodValueRef(ref int variable)
{
    variable = 2;
}
```

</div>
        </div>
        <div class="column col-6">
<div>

```csharp
static void Main(string[] args)
{
    int e;  
    
    MethodValueOut(out e);
    
    Console.WriteLine(e); // 3
}

// pass value by reference
static void MethodValueOut(out int variable)
{
    variable = 3;
}
```

</div>
        </div>
        <div class="column col-6">
<div>

```csharp
class City
{
    public int code;
    public City(int code)
    {
        this.code = code;
    }
}
    
static void Main(string[] args)
{
    City city = new City(12);
            
    MethodReference(city);

    Console.WriteLine(city.code); // 0
}

// pass the reference to the object on heap
static void MethodReference(City city)
{
    city.code = 0;
}
```

</div>
        </div>
      </div>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-2-5" />
    <label class="summary" for="accordion-2-5">
      <h5><strong>Boxing - Unboxing</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Операція упаковки - `boxing`-гу характеризується виділенням пам'яті на кучі під об'єкт значимого типу - value type і присвоєння ссилки на цю ділянку пам'яті змінної в стеці. Розпакування `unboxing`, навпаки, виділяє пам'ять в стеку під об'єкт, отриманий з кучі по ссилці.</p>
<div>

```csharp
int i = 123;      // a value type
object o = i;     // boxing
int j = (int)o;   // unboxing
```

</div>
    </div>
  </li>
</ul>

<Level id="csharp-essential-topics" number="3" name="Найважливіші теми C#" difficulty="Мамкин комп'юторщик." objectives="Зрозуміти SDK." labels={{ level: "Розділ", backToTop: "нагору", difficulty: "Складність:", objectives: "Мета:" }} />

<ul>
  <li class="details">
    <input type="checkbox" id="accordion-3-1" />
    <label class="summary" for="accordion-3-1">
      <h5><strong>Class vs Struct</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>`Kлас` проти `Cтруктури`. **Структури** по вигляу дуже схожі на **Класи**, але існує принципова відмінність, яка згадувалась раніше. Клас - це *reference type** і передається по ссилці, а структура - **value type** і передається за значенням - тобто копіюється.
      Структури краще використовувати для невеликих класів, маленьких структур даних та легковєсних об'єктів
      Щодо класів, то можна сказати що у всіх випадках де вам незручно використовувати структуру - використовуйте класи та не ускладнюйте собі життя.
      Класи чудово підходять для того щоб бути частиною ієрархії сутностей, мати внутрішнім стан та містити в собі велику кількість бізнес логіки.  </p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Static members</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Клас може мати статичні поля, методи та властивості. Якщо член класу статичний, то він відносяться до всього класу і для звернення до нього не треба створювати екземпляр класу.
      На прикладі показано що статичне поле є спільним для усіх об'єктів класу і може використовуватись і нестатичний методах. У той час як у статичних методах у нас немає доступу до нестатичних членів класу.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Params</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Використовуючи ключове слово params, ви можете вказати параметр методу, що він приймає довільну кількість аргументів - нуль або більше.
      Далі ці аргументи в тілі методі можна використовувати в контексті масиву.
      Передавати аргументи у метод в якого змінна кількість параметрів можна просто перераховуючи їх через кому як показано на слайді.
      Варто зазначити, що аргумент `params` повинен бути останнім і йти після усіх строго визначених аргументів методу.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Nullable</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Явно структурному типу даних ми не можемо присвоїти `null`. Щоб це зробити, на потрібно оголосити змінну з модифікатором `?`. Цей модифікатором являється алаясом до структури `Nullable&lt;T&gt;`, що є так званою обгорткою для структур, що і показано на сигнатурі.
      Обгортаючи змінну в `Nullable` тип у нас з'являється новий `АРІ` для взаємодії з цією змінною.
      * А саме властивіть `HasValue`, що повертає `true`, якщо змінна містить значення, або `false`, якщо вона `null`
      * Та `Value` повертає реальне значення яке зберігається у змінній, якщо `HasValue` дорівнює `true`. Інакше, викидає InvalidOperationException, якщо змінна `null`.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Interface vs Abstract Class</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>А ми рухаємось далі і переходимо до... `абстрактних класів` та  `інтерфейсів`
      У C# `абстракція` використовується для приховання деталей реалізації. 
      Це означає, що ми зосерджуємось на тому, що об'єкт може робити, а не на тому, як він це робить. Це особливо використовується для великих і складних програм. 
      Щоб цього досягти використовуються `абстрактні класи` та  `інтерфейси`.
      У `абстрактном класі` ми можемо створити функціональність, яка має бути реалізована у похідному класі. 
      З свого боку `інтерфейс` дозволяє визначити функціональні можливості або функції, але не може їх реалізувати. 
      Клас імплеменує інтерфейс та обов'язково реалізує ці методи, якщо він не є `абстрактним`.
      Розглянемо кілька ключових відмінностей між ними...</p>
      <p>
        1
        `Інтерфейс` не може мати модифікаторів доступу до членів - все що є в `інтерфейсі` по дефолтну є публічним.
        У абстрактного класу все залишається як і звичайного класу
        2
        Ми не можемо явно створити інстанс `Інтерфейсу` чи `абстрактного класу` викликавши конструкор.
        Хоча нагадаю що у `абстрактного класу` він може бути.
        Він здебільшого використовується для виклику у конструкторі `похідного класу`, щоб не дублювати код ініціалізації полів чи властивостей `абстрактного класу`.
        В `Інтерфейсі` ми можемо лише описати сигнатуру методу без його імплементації
        У `Абстрактному класі` ми можемо повністю імплементувати метод який нас цікавить. Для цього у метод має бути не абстрактним.
        3
        Ми не можемо оголосити конструктор у тілі інтерфейсу, ні з модифікатором доступу ні без нього.
        У Абстрактному класі ми можемо оголошувати конструктори з тими самими правилами, що і у звичайних класах
        4
        Ми не можемо явно створити інстанс `ітерфейсу` чи `абстрактного класу` викликавши конструкор.
        Хоча нагадаю що у `абстрактного класу` він може бути.
        Він здебільшого використовується для виклику у конструкторі `похідного класу`, щоб не дублювати код ініціалізації полів чи властивостей `абстрактного класу`.
        5
        `Інтерфейс` не може мати модифікаторів доступу до членів - все що є в `інтерфейсі` по дефолтну є публічним. У `абстрактного класу` все залишається як і звичайного класу
        6
        Абсолютно всі члени `інтерфейсу` є абстрактними, тобто не мають реалізації.
        А щодo `абстрактного класу`, то в ньому можуть бути як абстрактні методи та властивості так і не абстрактні - з повною, або частковою реалізацією.
      </p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Interface vs Abstract Class - Conclusion</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Отже, коли ми дізналися про головні характеристики `абстрактного класу` та  `інтерфейсу`, назріває питання - 'що і коли вибрати?'.
      Інтерфейс краще підходить у випадках, коли потрібно, щоб кілька класів імплементували інтерфейс.
      Члени інтерфейсу не можуть бути статичними. Абстрактний клас надає можливість зберігати стан класу в цілому, а не окремого об'єкту.
      C# не підтримує множинне наслідування, як С++, а інтерфейси в основному використовуються щоб це зробити. Так як клас може реалізовувати більше одного інтерфейсу і наслідуватись лише від одного абстрактного класу. 
      Абстрактний клас використовується якщо ми хочемо його включити в ієрархію успадкувань. І створити функціонал з повною або частковою реалізацією, яку клас наслідник може імплементувати або перевизначити. 
      Інтерфейс в основному використовується тільки тоді, коли ми хочемо просто описати `API` використання класів які будуть імплементувати цей інтерфейс.
      Таких класів гіпотетично може бути декілька і швидше за все - це не єдиний інтерфейс який вони будуть імплементувати.
      Це саме той випадок коли інтерфейс є чи не єдиним правильним рішенням </p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Extension methods</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>`Extension` методи дозволяють "додавати" методи до існуючих типів без створення нового похідного типу, перекомпіляції або модифікації оригінального типу.
      `Extension` метод це особливий статичним методом, який має обов'язково бути членом статичного класу.
      На прикладі показано `Extension` метод для типу `String`. Статичний клас може мати довільну назву, в той час як назва методу має відрізнятись від уже існуючих методі у класі який ми розширюємо.
      Надалі ми можемо використовувати оголошений нами метод як і звичайні методи класу який ми розширюємо. </p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Generics</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>`Дженеріки`. Вони були додані до мови <strong>C#</strong> з другої версії.
      `Дженеріки` привнесли в <strong>.NET</strong> концепт типізованих параметрів, що дозволяє проектувати класи та методи, які відкладають визначення типу одного, або більше членів класу чи методу, допоки вони не будуть ініціалізовані тим, хто їх використовує.
      Наприклад: використовуючи загальний параметр типу `Т`, чи можемо написати єдиний клас, який може використовуватись клієнтським кодом без ризику здійснення операцій `boxing-y` які є самі по собі важкими операціями і зловживати ними не є добре.  
      Як видно з наведеного вище коду, MyGenericClass визначений з `&lt;T&gt;`. `&lt;&gt;` вказує, що `MyGenericClass` є дженеріком, і тип `Т` буде визначено пізніше. Можете використовувати будь-які букви або слово замість `T`, це немає значення.
      Тепер компілятор призначає тип членів класу на основі типу, переданого  програмістом при створенні класу. Наприклад, наступний код використовує тип даних `int`.
      #### **Constraints in Generics**
      У C# є `Constraint`-и, для того щоб обмежити які типи можна використовувати у дженерік класі. Наприклад, якщо `Constraint`-ом ми вказуємо що типом `Т` може бути тільки `reference type`, тобто `класи`, то не можна використати `value type`-и для створення екземпляру дженерік класу.
      Тож тепер ми не можемо використовувати структурні типи даний як int - це викличе помилку компіляції
      #### **All Constraints in Generics**
      Тут зібрані усі можливі Constraint-и, якими можна обмежувати типи, для використання в дженерік класах.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Tuples</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Якщо вам потрібно склеїти два значення, щоб повернути їх з функції або помістити два значення в хеш-набір, ви можете використовувати типи System.ValueTuple і створити їх за допомогою зручного синтаксису:
      1. Приклад створення кортежу
      2. Використання кортежу для типізування Dictionary
      3. Додавання елементу кортеду в Dictionary
      4. Дістаємо значення словника по ключу
      5. Деструктуризація елементу кортежу
      6. Доступ до членів кортежу по імені 
      7. Приклад того як повертати з функції значення в кортежі</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Events & Delegates + Lambdas</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Тепер переходимо до Подій та Делегатів. 
      Делегати це об'єкти, які вказують на методи. За допомогою них ми можемо викликати дані методи.
      Тут зібрані усі можливі Constraint-и, якими можна обмежувати типи, для використання в дженерік класах.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong>Program Example</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Спочатку ми оголошуємо сигнатуру делегату.
      Це означає, що методи, на які може вказувати делегат мають мати такі ж самі параметри та повартаючий тип, що і делегат.
      У нашому випадку делегат LogMessage має 1 параметр стрінг і повертає нічого.
      В класі програм ми оголосили 2 методи LogRedMessage та LogGreenMessage з тою самою сигнатурою що і у делегата, тому ми можемо присвоїти йому посилання на ці методи.
      Спочатку ми створюємо змінну делегату, присвоюючи йому адресу методу LogRedMessage і викликаємо його за допомогою методу делегата Invoke, передаючи у цей метод параметри - а саме 1-ну стрічку "Hello world!".
      Далі ми додаємо посилання на ще 1 метод LogGreenMessage цьому делегату і  при наступному виконанню делегата, ми уже викличемо 2 методи які ми заасайнили цьому делегату і у консоль виведуться 2 стрічки "Second message" червоного та зеленого кольору. 
      Викликати делегат можна і без Invoke, просто за допомогою круглих дужок, передавши аргументи.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-3-2" />
    <label class="summary" for="accordion-3-2">
      <h5><strong></strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p></p>
    </div>
  </li>
</ul>

#### **Action, Func і Predicate**

Замість визначення нового типу делегата, можна використовувати делегати Action, Func і Predicate. 

Дженерік делегат Action &lt;T&gt; призначений для ссилки на метод, що повертає void. Класу цього делегата можна передавати до 16 параметрів довільного типу.

--------------------------------

Делегати Func можуть використовуватися аналогічним чином. Func дозволяє викликати методи які щось повертають. Йому так само можна передавати до 16 типів параметрів і 1 тип який він повертає. 

--------------------------------

Делегат Predicate, як правило, використовується для порівняння деякого об'єкта T певній умові. Він повертає true, якщо об'єкт задовільняє умову, і false, якщо ні.
**Щоб підсумувати варто сказати, що суть делегатів у тому, що вони дозволяють представляти методи у вигляді об'єктів і передавати їх до функцій, використовувати як колбеки і так далі.**
#### **Events & Delegates Flow**

З делегатами розібралися, переходимо до подій... 

Події дозволяють сигналізують системі про те, що відбулося певна дія.

Існує така модель Видавець-Підписник.

Підписник підписується на подію, визначає обробник і чекає допоки Видавець викличе цю подію.

#### **Demo**

Звучить просто, подивимся як буде на практиці i переходимо до **Demo**.

Я підготував клас `Wallet` - гаманець. Говорити про поля і тд

Події оголошуються в класі з допомогою ключового слова event, після якого йде назва делегата.

Зв'язок з делегатом означає, що метод, який обробляє цю подію, має мати сигнатуру делегату.

#### **Collections - Hierarchy**

Хоча в мові C# є `масиви`, які зберігають в собі набори однотипних об'єктів, але працювати з ними не завжди зручно.

Так як масив зберігає фіксовану кількість об'єктів, а ми заздалегідь не знаємо, скільки у нас буде об'єктів, в цьому випадку набагато зручніше буде застосовувати колекції.

Визначну роль у виборі колекцій може зіграти те, що деякі з них реалізують стандартні структури даних, такі як:
* стек
* чергу
* словник
* і так далі

які можуть стати в нагоді для вирішення різних спеціальних завдань.

Основою для створення всіх колекцій є реалізація інтерфейсів `IEnumerator` і `IEnumerable`. 

Інтерфейс `IEnumerator` представляє `Перечислитель`, за допомогою якого стає можливий послідовний перебір колекції, наприклад, в циклі `foreach`.

А інтерфейс `IEnumerable` через свій метод `GetEnumerator` надає Перечислитель всім класам, які реалізують даний інтерфейс.

Тому інтерфейс `IEnumerable` є базовим для усіх колекцій.

#### **ArrayList & List**

На прикладі використовуються дві колекції: `non-generic` - `ArrayList` та `generic` - `List`.

Зараз хорошою практикою вважається використовувати дженерік версії коллекцій де це тільки можливо - через строгу типізацію та зручність у використанні.

Більшість колекцій підтримують додавання елементів.

Наприклад, в даному випадку додавання проводиться методом `Add`, але для інших колекцій назву методу може відрізнятися.

Також більшість колекцій реалізують видалення (в даному прикладі проводиться за допомогою методу `RemoveAt`).

За допомогою властивості `Count` у колекцій можна подивитися кількість елементів.

І так як колекції реалізують інтерфейс `IEnumerable`, то всі вони підтримують перебір в циклі `foreach`.

Конкретні методи і способи використання можуть відрізнятися від одного класу колекції до іншої, але загальні принципи будуть одні і ті ж для всіх класів колекцій.

#### **List is Array wrapper**

По суті такі колекції як `ArrayList`, `List`, `Stack`, `Queue` та інші це ніщо інше як зручні обгортки над `масивами` для роботи з набором даних.

Зараз я продемонструю створення власноЇ колекції на основі масиву та покажу як можна проходитись по ній в циклі ForEach.

Kолекцію буде називатись `CustomCollection`.

#### **Exceptions**

Іноді при виконанні програми виникають помилки, які важко або неможливо передбачити. 

Наприклад, при передачі файлу по мережі може обірватися підключення, інтернет пропаде, такі ситуації називаються Exception-ами.

Мова C# надає розробникам можливості для обробки таких ситуацій засобами конструкції try...catch...finally.

При використанні блоку try...catch...finally спочатку виконуються всі інструкції в блоці try.

Якщо в цьому блоці не виникло Exception-ів, то після нього  виконається блок finally і конструкція try..catch..finally завершить свою роботу.

Якщо ж в блоці try виникає Exception, то звичайний флов виконання зупиняється, і CLR починає шукати блок catch, який може обробити цей Exception.

Якщо блок catch знайдений, то він виконується, і після його завершення виконається блок finally.

Якщо потрібний блок catch не знайдений, то програма аварійно завершує своє виконання.

#### **Demo**

Покажу це все на практиці.

... 

Пишу код, вилітає помилка

Пишу трай, кетч, ловлю помилку і розказую про властивості об'єкту помилки

Базовим для всіх типів еxception-ів є тип Exception. Цей тип визначає ряд властивостей, за допомогою яких можна отримати інформацію про Exception.

InnerException: зберігає інформацію про Exception, через який виник цей Exception

Message: зберігає повідомлення про Exception, текст помилки

Source: зберігає ім'я об'єкта або збірки, яка викинула Exception

StackTrace: повертає колл стек викликів, які привели до Exception-а

TargetSite: повертає метод, в якому було відбувся Exception

#### **Exceptions Hierarchy**

У C# всі типи Exception-ів наслідуються від батьківського класу Exception, який додатково поділяється на дві гілки SystemException і ApplicationException.

SystemException - це базовий клас для всіх помилок CLR або програмного коду.

ApplicationException - це базовий клас для всіх Exception-ів, пов'язаних із додатком.

У випадку ApplicationException, є можливість створювати свої власні типи Exception-ів, успадкувавшись від класу Exception

SystemException містить всі відомі типи Exception, такі як DivideByZeroException або NullReferenceException і так далі.

#### **Demo Hierarchy**

...

#### **throw - Demo**

Після оператора throw вказується об'єкт Exception-a, в конструктор якого ми можемо передати повідомлення про помилку. Замість типу Exception ми можемо використовувати об'єкт будь-якого іншого типу Exception.

Подібним чином ми можемо генерувати Exception-и в будь-якому місці програми. Але існує також і інша форма використання оператора throw, коли після цього оператора нічого не вказується.

У подібному вигляді оператор throw може використовуватися тільки в блоці catch.

Різниця між ними у тому, що throw без нічого зберігає початковий stack trace, у той час як throw ех скидує stack trace до методу у якому зараз відбувається обробка Exception-у

----------------------------------

<Level id="clean-code-principles" number="4" name="Принципи чистого коду" difficulty="Такоє." objectives="Не придумано ще." labels={{ level: "Розділ", backToTop: "нагору", difficulty: "Складність:", objectives: "Мета:" }} />

<ul>
  <li class="details">
    <input type="checkbox" id="accordion-4-1" />
    <label class="summary" for="accordion-4-1">
      <h5><strong>Coding Standards and <code>NamingConventions</code></strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>В перекладі на людську мову — загальноприйняті стандарти написання коду та узгоджені правила, як називати змінні, функції і інше. Це — граматика і орфографія C#, прийнята більшістю .NET-розробників для того, щоб інші девелопери <em>(ви через Х часу)</em> могли легко та швидко зрозуміти, що відбувається у вашому коді та використовувати його, не плутаючись у всіх можливих способах назвати, скажімо, аргумент <em>(і такі правила написання є абсолютно у всіх мовах програмування, не тільки в С#)</em>. Довго розповідати про кожне з правил нема сенсу, головне для вас — самостійно ознайомитися з <a href="https://www.dofactory.com/reference/csharp-coding-standards">списком більшості поширених стандартів C#</a>.</p>
      <div class="bubble small subtle">
        Хочете виглядати цивілізованим розробником і мати повагу від колег — прочитайте кілька абзаців Readme з прикладами правильно оформленого коду і дотримуйтеся такого формату, виконуючи таски малі чи великі.
      </div>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-4-2" />
    <label class="summary" for="accordion-4-2">
      <h5 style="display: flex; align-items: center;">
        <span style="margin-right: 0.25em;">DRY</span>
        <small style="font-size: 0.5em; text-transform: uppercase;">
          <span style="text-decoration: line-through; opacity: 0.75; margin-right: 0.25em;">Don't Repeat</span>
          <span style="text-decoration: line-through; opacity: 0.75; margin-right: 0.25em;">Don't Repeat</span>
          <span style="text-decoration: line-through; opacity: 0.75; margin-right: 0.25em;">Don't Repeat</span>
          <span style="text-decoration: line-through; opacity: 0.75; margin-right: 0.25em;">Don't Repeat</span>
          Don't Repeat Yourself
        </small>
      </h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p><strong>Не повторюйся</strong> при написанні коду = не прописуй кілька разів те, що можна закодити один раз, і викликати, звертаючись до конкретного модуля. Приклад — веб-додаток, що містить кілька однакових за оформленням блоків, і кожен з них має власний <em>(ідентичний іншим!)</em> опис стилів. Яка ймовірність, що коли потрібно буде внести однакову зміну в усіх цих блоках <em>(вручну, адже ми кілька разів повторюємо той самий набір стилів)</em>, розробник пропустить один чи кілька з них? Коли цей принцип порушено і імплементація методу чи навіть класу дублюється без справжньої потреби, а написано кілька сотень тисяч рядків коду (як на будь-якому реальному проекті), то щоб відрефакторити, змінити бізнес логіку чи внести прості зміни до інтерфейсу, доводиться довгенько шукати по імені методу нещасний кусок коду, часто для того, щоб поміняти у цьому лише 1 цифру.</p>
      <div class="bubble small subtle">
        Так не робиться 😐. Щоб досягнути DRY у вашому коді - діліть ваш код на маленькі кусочки, бачите що частина логіки повторюється - одразу виносьте, компонуйте функції. Чому потрібен DRY? Чим менше коду, тим краще. Його легше підтримувати, менше часу йде на те, щоб у ньому розібратися і також зменшується кількість багів.
      </div>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-4-3" />
    <label class="summary" for="accordion-4-3">
      <h5 style="display: flex; align-items: center;">
        <span style="margin-right: 0;"><strong>KISS<sup>💋</sup></strong></span>
        <small style="font-size: 0.5em; text-transform: uppercase;">
          Keep It Simple Stupid
        </small>
      </h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Цей принцип говорить сам за себе ― простий і лаконічний код легше зрозуміти іншим розробникам і тобі, коли ти повернешся до нього за якийсь час. Він формулюється так — кожен метод повинен вирішувати лише одну маленьку проблему, а не мати багато різних засобів вжитку. Якщо у методі багато умов, то розбийте їх на менші методи. Це буде легше читати, підтримувати і це також допоможе знайти помилки набагато швидше. Щоб продемонструвати KISS, найчастіше приводять приклад із визначенням дня тижня:</p>
      <div class="columns">
        <div class="column col-6">
          <h6><strong>Simple</strong></h6>
<div>

```csharp
string weekday(int day) {
    switch (day) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        case 4:
            return "Thursday";
        case 5:
            return "Friday";
        case 6:
            return "Saturday";
        case 7:
            return "Sunday";
        default:
            throw new Exception("Day must be in range 1 to 7");
    }
}
```

</div>
        </div>
        <div class="column col-6">
          <h6><strong>Stupid</strong></h6>
<div>

```csharp
string weekday(int day) {
    if ((day < 1) || (day > 7))
    {
        throw new Exception("Day must be in range 1 to 7");
    }
    
    string[] days = {
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday"
    };

    return days[day - 1];
}
```

</div>
        </div>
      </div>
      <div class="bubble small subtle">
        На слайді показано два методи для вирішення цієї задачі.<br />Перше рішення просте як двері ― простий switch з дефолтним запасним варіантом у випадку якщо день не знайдено.<br />Другий метод теж робочий, але для того щоб його зрозуміти, потрібно довший час вчитуватися (<em>дивишся на індексатор, з масиву днів по індексу дня дістаєш необхідний... але номер дня має на додачу -1... звідки мінус?.. а-а-а-га, бо масив починається з нуля і треба віднімати одиницю... ну, seems legit)</em>.<br />Такий код існує повсюди, але він дійсно незручний і виглядає непрофесійно, 99% програмістів вибрали б працювати з чимось схожим на перший варіант. Щоб досягнути KISS ― старайтесь писати максимально простий код. Якщо бачите важку (нечитабельну) ділянку коду, пошукайте більш лаконічне вирішення тої ж самої задачі, і, відрефакторивши написане, ви здивуєтеся, що кусок на 200 рядків насправді не такий вже й необхідний!
      </div>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-4-4" />
    <label class="summary" for="accordion-4-4">
      <h5 style="display: flex; align-items: center;">
        <span style="font-weight: 900; margin-right: 0.25em;">SOLID</span>
        <small style="font-size: 0.5em; text-transform: uppercase;">
          Single responsibility, Open–closed, Liskov substitution, Interface segregation, Dependency inversion
        </small>
      </h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>SOLID — це <strong>5 принципів об'єктно-орієнтованого програмування</strong>, які описують архітектуру програмного забезпечення:</p>
      <ul>
        <li class="details">
          <input type="checkbox" id="accordion-4-4-1" />
          <label class="summary" for="accordion-4-4-1">
            <strong>Single responsibility</strong>
          </label>
          <div class="details-body">
            <p>Принцип єдиної відповідальності. Він означає, що кожен клас чи структура повинна відповідати лише за 1 ціль. Всі члени класу мають бути зв'язані єдиною метою і працювати разом щоб її досягти. Принцип єдиної відповідальності дає нам спосіб щоб для визначення класів ще на етапі проектування програми. Хорошого розподілу обов'язків можна досягти лише тоді коли в нас є повна картина того,як має працювати програма і ми знаємо точно хто й за що має відповідати.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
  <div>

```csharp
class Task
{
    public string Title { get; set; }
    public string Description { get; set; }

    // Adds task in Database
    public bool Add(Task tast)
    {
        // Internal realization(Insert into DB)
    }

    // Estimate Task's duration
    public void EstimateTaskDuration(Task tast)
    {
        // Calculation Task's difficulty, estimating
    }
}
```

  </div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```csharp
class Task
{
  public string Title { get; set; }
  public string Description { get; set; }

  // Adds task in Database
  public bool Add(Task tast)
  {
      // Internal realization(Insert into DB)
  }
}

class TaskEstimator
{
    // Estimate Task's duration
    public void EstimateTaskDuration(Task tast)
    {
        // Calculation Task's difficulty, estimating
    }
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">
              На прикладі класу Task, можна показати, що він не відповідає Single Responsibility Principle, так як він відповідає і за збереження Задачі в Базу Данних а також виконує бізнес логіку по обрахуванню та визначенню часу потрібного на вирішення Задачі. Клас Task не має нести відповідальність за обрахунок часу на її виконання, бо якщо через деякий час, у замовника поміняються вимоги до виконання усіх задач, тому що скоро реліз, або програмістів на проекті стало менше. І нам потрібно буде поміняти клас Task, якому взагалі по барабану на те що у вас реліз, Task-у треба зробити і все. Згідно Single Responsibility Principle, один клас має взяти на себе відповідальність, тому ми маємо створити окремий клас для естімейту Завдань, на основі бізнес логіки, задачі та зовнішніх чинників.
            </div>
          </div>
        </li>
        <li class="details">
          <input type="checkbox" id="accordion-4-4-2" />
          <label class="summary" for="accordion-4-4-2">
            <strong>Open–closed</strong>
          </label>
          <div class="details-body">
            <p>Принцип відкритості-закритості. Головнa концепція даного принципу є те, що клас повинен бути відкритий для розширення, але закритий для модифікацій. Наш модуль повинен бути розроблений так, щоб нова функціональність додавалась тільки при створенні нових вимог. «Закритий для модифікацій» означає, що ми вже розробили клас, ми не повинні міняти його, тільки якщо не знайдемо помилки що виправити її. У мові C# для реалізації цього принципу ідеально підходить успадкування.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
<div>

```csharp
class Mockup
{
    public string ImageType { get; set; }

    public Image ConvertImage(Image img)
    {
        if (ImageType == "tiff")
        {
            // Convert Image to the tiff format
        } 
        
        if (TypeReport == "cdr")
        {
            // Convert Image to the cdr format
        }
    }
}
```

</div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```csharp
abstract class Mockup
{
    public virtual void ConvertImage(Image img)
    {
        // Base realization that common for each format
    }
}

class MockupTiff : Mockup
{
    public override Image ConvertImage(Image img)
    {
        // Convert Image to the tiff format
    }
}

class MockupCdr : Mockup
{
    public override Image ConvertImage(Image img)
    {
        // Convert Image to the cdr format
    }
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">Розглянемо приклад з мокапом. Проблема цього класу в тому, що коли замовник захоче подивитись на мокап який намалювали дизайнери, але у нього не відкриває картинки формату tiff чи cdr тоді треба буде вносити новий формат картинки наприклад png. І для цього ми будем змушені додати нову умову if, що противорічить Open Closed Principle. На другому прикладі показано як це можна вирішити. Є базовий абстрактний клас Mockup, який частково реалізує конвертацію картинки, а дочірні класи реалізують конвертацію картинки в певний формат. І якщо ми захочемо добавити ще 1 формат, нам просто тре буде створити ще 1 клас унаслідуватись від Mockup і реазілувати метод.</div>
          </div>
        </li>
        <li class="details">
          <input type="checkbox" id="accordion-4-4-3" />
          <label class="summary" for="accordion-4-4-3">
            <strong>Liskov substitution</strong>
          </label>
          <div class="details-body">
            <p>За принципом пiдстановки Лiсков ми повинні мати можливість використовувати будь-який похідних клас замість батьківського і використовувати його так само, не вносячи зміни. Дочірній клас не має порушувати визначення типу батькіського класу та його поведінку.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
<div>

```csharp
abstract class Developer
{
    public virtual string CodeWebApp()
    {
        return "Coding Front-End Web App";
    }
    public virtual string CodeServer()
    {
        return "Coding Back-End Server";
    }
}
class JavaScriptDeveloper: Developer
{
    public override string CodeWebApp()
    {
        return "Coding Front-End with Angular";
    }
    public override string CodeServer()
    {
        return "Coding Back-End with Node.js";
    }
}
class CSharpDeveloper: Developer
{
    // C# Developer can't  create Front-End App
    public override string CodeWebApp()
    {
        throw new NotImplementedException(); 
    }
    public override string CodeServer()
    {
        return "Coding Back-End with ASP.Net";
    }
}
```

</div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```
interface IFrontend
{
    string CodeWebApp();
}

interface IBackend
{
    string CodeServer();
}

class JavaScriptDeveloper: IFrontend, IBackend
{
    public string CodeWebApp()
    {
        return "Coding Front-End with Angular";
    }
    public string CodeServer()
    {
        return "Coding Back-End with Node.js";
    }
}

class CSharpDeveloper: IBackend
{
    public string CodeServer()
    {
        return "Coding Back-End with ASP.Net";
    }
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">Давайте подивимося приклад з Розробниками. Developer є батьківський класом для JavaScript i C# Developer-ів. Як бачимо у нас клас Developer може створювати бекенд і фронтенд додатки. Здавалося б усе добре. JavaScript Developer успішно реалізовує 2 методи. А от з  C# Developer не все так просто, він може написати сервер на ASP.Net-і, але створити класного фронтенду. І якщо ми захочемо це зробити, то у нас вилетить Ексепшн. Для того щоб вирішити цю проблему нам потрібно розділити функціонал Developer-а на 2 частини: IFrontend та IBackend і реалізувати ці інтерфейси де ми маємо змогу. JavaScript Developer у нас реалізовує і Frontend і Backend, а C# Developer: тільки Backend.</div>
          </div>
        </li>
        <li class="details">
          <input type="checkbox" id="accordion-4-4-4" />
          <label class="summary" for="accordion-4-4-4">
            <strong>Interface segregation</strong>
          </label>
          <div class="details-body">
            <p>Принцип розділення інтерфейсів говорить, що клієнти не повинні примусово імплементовувати інтерфейси, які вони не використовують.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
<div>

```csharp
interface IDeveloper
{
    string CodeDesktop();
    string CodeServer();
}
```

</div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```csharp
interface IDesktop
{
    string CodeDesktop();
}

interface IBackend
{
    string CodeServer();
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">Давайте припустимо, що у нас є Інтерфейс IDeveloper, який тепер вміє написати сервер і десктоп додаток. Як і до дого у нас є JavaScript та C# Developer-и які успішно можуть це зробити. На JavaScript-і писався би під Електрон, а на C# WPF додаток. Все класно, всі задоволені. Але не всьо так просто. Шеф сказав, що ті додатки на Електрон-і в нього лагають і взагалі дорого платити цим JavaScript-розробникам. Урізаєм проекти під десктоп на JavaScript-і, пишем тіки на WPF. Але виходить ми ломаємо принцип Interface Segregation, бо JavaScript розробники все ще пишуть декстоп проекти. І рішенням цієї проблеми буде знову ж таки розділення інтерфейсу на кілька. На IDesktop та на IBackend. Це похоже до минулого прикладу, але тут ми вирішуєм іншу поблему - не даємо класу робити більше ніж потрібно.</div>
          </div>
        </li>
        <li class="details">
          <input type="checkbox" id="accordion-4-4-5" />
          <label class="summary" for="accordion-4-4-5">
            <strong>Dependency inversion</strong>
          </label>
          <div class="details-body">
            <p>І тепер останній і мабуть найважчий для розуміння принцип - інверсії залежностей. Цей принцип гласить, що:</p>
            <ol>
              <li>По-перше, класи високого рівня не повинні залежати від низькорівневих класів, при цьому обидва мають залежати від абстракцій.</li>
              <li>По-друге, абстракції не повинні залежати від деталей, але деталі мають залежати від абстракцій.</li>
            </ol>
            <p>Що це значить? А це значить, що класи високого рівня реалізують бізнес-правила або логіку в системі. Низькорівневі класи займаються більш детальними операціями, як от роботою з Базою Даних, передачею повідомлень в операційну систему і так далі. Щоб досягти інверсії залежностей ми повинні тримати ці високорівневі і низькорівневі класи настільки слабо зв'язними, наскільки можливо. Для цього нам потрібно зробити їх залежними від абстракцій, а не один від одного.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
<div>

```csharp
class Email
{
    public void Send()
    {
        // Code to send email-letter
    }
}

class Notification
{
    private Email email;
    public Notification()
    {
        email = new Email();
    }

    public void EmailDistribution()
    {
        email.Send();
    }
}
```

</div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```csharp
interface IMessenger
{
    void Send();
}

class Email : IMessenger
{
    public void Send()
    { /* Code to send email-letter */ }
}

class SMS : IMessenger
{
    public void Send()
    { /* Code to send SMS */ }
}

class Notification
{
    public IMessenger Messenger { get; set; };
    public Notification(IMessenger mess)
    {
        Messenger = mess;
    }

    public void Notify()
    {
        Messenger.Send();
    }
}

static void Main(string[] args)
{
    var notification = new Notification(new Email());
    notification.Notify(); // Sent email
    notification.Messenger = new SMS(); // Change the provider
    notification.Notify(); // Sent SMS
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">Давайте розглянемо цей принцип на прикладі розсилки повідомлень. На першому сніппеті коду клас Notification повністю залежить від класу Email, тому що він відправляє тільки один тип повідомлень. Якщо ми захочемо відправляти повідомлення якимсь іншим способом? Тоді нам треба буде перелопачувати всю систему повідомлень. Це є признаком того, що система є тісно св'язною. Для того щоб зробити її слабо зв'язною, нам потрібно абстрагуватися від провайдера відправки повідомлень, а саме - Емейл-у.  Для цього ми створюємо interface IMessenger з методом Send і реалізуємо його у двох класах - Email і SMS. Клас Notification ми дизайнимо так, щоб відв'язатись від конкретної реалізації розсилки повідомлень. В цьому випадку ми можемо використати принцип dependency injection, прокинувши об'єкт Messenger-а через конструктор. І в залежності від того, екземпляр якого класу це буде, такі повідомлення ми і будемо відсилати. Ось на прикладі ми створюємо Notification з Email Messenger-ом, посилаємо емейл. Далі ми захотіли поміняти провайдера, і присвоюємо властивості Messenger - SMS-провайдер. Наступний виклик методу Notify уже надішле SMS-ку.</div>
          </div>
        </li>
      </ul>
      <p>Кожен принцип SOLID пропонує нам шлях до написання логічного, надійного та зрозумілого коду, а мова С#, при дотриманні цих принципипів, дає змогу писати великі програми та легко розширювати їх.</p>
    </div>
  </li>
</ul>

<ThatsAllFolks />
<div class="bubble">
  Я можу довго говорити про C# та .NET, але в цій лекції поділився основним, на мою думку, для вас на даний момент. На тому все, дякую за увагу, ставте оцінку лекції в ваших особистих кабінетах, залишайте відгук, задавайте питання, робіть домашку і до зустрічі на код-рев'ю! 👋
</div>

export const metadata = {
  author: "Rostyslav Diakiv",
  title: ".NET ecosystem and C# best practices",
  description: "",
  keywords: ["hola", "guapa"]
}

export default Lecture;