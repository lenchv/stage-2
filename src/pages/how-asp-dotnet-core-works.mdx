import { Lecture, Message, TimelineOfContents, Level, ThatsAllFolks } from "../components";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faGlobe } from "@fortawesome/pro-solid-svg-icons";
import { faFacebookSquare, faGithub } from "@fortawesome/free-brands-svg-icons";
import nikitaKrasnovAvatar from "../assets/avatars/nikita-krasnov-2018.svg";

<div><h1><strong>How ASP.NET Core works</strong></h1></div>

<div>
  <div class="author">
    <div id="avatar-wrapper">
      <object id="avatar" data={nikitaKrasnovAvatar} role="img" aria-label="My profile picture"></object>
    </div>
    <div class="profile">
      <h3 class="name">Никита Краснов</h3>
      <ul class="contacts">
        <li>
          <a href="https://www.facebook.com/krsnv" rel="author" class="facebook">
            <FontAwesomeIcon icon={faFacebookSquare} className="icon" />
            <span>Nikita Krasnov</span>
          </a>
        </li>
        <li>
          <a href="https://github.com/EclipticaSonos" rel="author" class="github">
            <FontAwesomeIcon icon={faGithub} className="icon" />
            <span>EclipticaSonos</span>
          </a>
        </li>
        <li><a href="https://www.linkedin.com/in/nikita-krasnov-b51244116/" rel="author" class="linkedin"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14 icon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><span>nikita-krasnov</span></a></li>
      </ul>
      <p class="about">
        Нікіта працює бекенд-розробником в <a href="https://binary-studio.com"><strong>Binary Studio</strong></a>, не вживає алкоголю, але вживає .NET фреймворки, електронну музику, функціональне програмування і футболки з приколами-прінтами. Відвідує технічні мітапи та конференції, і вам радить спробувати — після завершення домашнього завдання для цієї лекції :Р
      </p>
    </div>
  </div>
  <div class="bubble" style="margin: -0.5em 1em 1em;">
    <strong>Hello guys!</strong><br />I am giving notes for this lecture in English, because for every developer <em>(and I hope you are going to become ones!)</em> it is important to be able to read documentation, which is rarely translated from English. On the way I will give you all hints and guidelines neccessary to understand how our tech stack works, and by the end of this lesson you will have live web app in ASP.NET Core. 
    <br />
    Want to try it out? Set up your workplace and let's go!
  </div>
</div>

<div id="table-of-contents" class="table-of-contents">
  <TimelineOfContents timeline={[{
    linkTo: "#Intro",
    title: "Welcome word. Intro"
  }, {
    linkTo: "#asp-net-core",
    title: "ASP.NET Core. Start with creating a new app"
  }, {
    linkTo: "#creating-controllers-and-services",
    title: "Creating controllers and services"
  }, {
    linkTo: "#additional-features",
    title: "Additional Features"
  }]} />
</div>


<Level id="intro" number="1" name="Welcome word. Intro" difficulty="No worries" objectives="Familiarize yourself with .NET basics because you are going to be buddies." />

<h4>How Microsoft came up with .NET Core</h4>
<p>There were times when the term <strong>.NET</strong> meant Windows platform only. It imposed some restrictions for deploying, because most machines have Linux as operating system. So the guys in Microsoft gathered for a meeting and came up with .NET Core. The main idea of the framework is cross-platform apps, which means you can host your app on a variety of OS. Furthermore, it’s open-source, hence it has great community support.</p>

<h4>Advantages</h4>
* <em>Cross-platform</em>: Runs on Windows, Linux, MacOS.
* <em>Flexible deployment</em>: the framework can be included in your app or installed side-by-side user-or machine-wide.
* <em>Command-line tools</em>: .NET Core has great CLI, therefore all product scenarios can be executed using command-line.
* <em>Compatibility</em>: .NET Core is compatible with .NET Framework, Xamarin and Mono, via the .NET Standard Library.
* <em>Open-source</em>: The .NET Core platform is open source, using MIT and Apache 2 licenses. You are welcome to contribute.
* <em>Supported by Microsoft</em>: Huge corporation forces .NET Core to develop and gain new features.

<h4>What you can build with .NET Core</h4>
* <em>ASP.NET Core MVC</em>: Web apps which implement Model-View-Controller pattern and use Razor for HTML markdown with C# snippets.
* <em>ASP.NET Core WebAPI</em>: Backend app which implements business logic and can be used by any client (whether it’s angular/react/whatever_framework-based frontend, mobile apps, etc.).
* <em>UWP (Universal Windows Platform)</em>: Native applications for phones, laptops, tablets, XBox, IoT.

<h4>What you need to start (Prerequisites, .NET SDK)</h4>
<p>You need to have a PC/laptop with Windows/Linux/MacOS system installed. 
Microsoft provides two options: .NET Runtime and .NET SDK. You can choose the one here.</p>
* <em>.NET Runtime</em> includes just the resources required to run existing .NET Core applications. The runtime is included in the SDK.
* <em>.NET Core SDK</em> includes everything you need to build and run .NET Core applications, using command line tools and any editor (including Visual Studio).

<p>In order to complete the homework you have to use <strong>.NET Core SDK</strong>.</p>

<h4>CLI-commands</h4>

* <em>dotnet new</em> — Initializes a sample console C# project
* <em>dotnet restore</em> — Restores the dependencies for a given application
* <em>dotnet build</em> — Builds a .NET Core application
* <em>dotnet publish</em> — Publishes a .NET portable or self-contained application
* <em>dotnet run</em> — Runs the application from source
* <em>dotnet test</em> — Runs tests using a test runner specified in the project.json
* <em>dotnet pack</em> — Creates a NuGet package of your code

<h4>Visual Studio only? Rider, VSCode, Sublime, etc.</h4>
<p>Since you are not limited to Windows only, you can choose whatever IDE/Text editor you want (<a href="https://visualstudio.microsoft.com/">Visual Studio</a>, <a href="https://code.visualstudio.com/">Visual Studio Code</a>, <a href="https://www.jetbrains.com/rider/">JetBrains Rider</a>, <a href="https://www.sublimetext.com/">Sublime</a>, <a href="https://atom.io/">Atom</a> and so on). You are able to write code using your favorite tool and execute needed actions using CLI.
I would recommend using <strong>Visual Studio Code</strong> for the homework.</p>


<Level id="asp-net-core" number="2" name="ASP.NET Core. Start with creating a new app" difficulty="It gets warmer, some actual copypasting is required" objectives="Bring a starter of ASP.NET Core web app to your console." />

<h4>What is ASP.NET Core</h4>
<p>ASP.NET is a popular web-development framework for building web apps on the .NET platform.</p>

<p>ASP.NET Core is the open-source version of ASP.NET, that runs on macOS, Linux, and Windows. ASP.NET Core was first released in 2016 and is a re-design of earlier Windows-only versions of ASP.NET.</p>

<p>In comparison to ASP.NET, Core version provides:</p>

* Cleaner and modular architecture
* Tighter security
* Reduced servicing
* Improved performance

<h4>Why use it</h4>

* Integration of modern client-side frameworks and development workflows
* A cloud-ready environment-based configuration system
* Built-in dependency injection
* New light-weight and modular HTTP request pipeline
* Ability to host on IIS or self-host in your own process
* Built on .NET Core, which supports true side-by-side app versioning
* Ships entirely as NuGet packages
* New tooling that simplifies modern web development
* Build and run cross-platform ASP.NET apps on Windows, Linux and MacOS
* Open-source and community focused

<h4>Let’s create a new app</h4>
Create a new app by executing the next command: <code>dotnet new webapi</code>

<h6>Program.cs</h6>
This is how the entry point looks like: 
```
public static void Main(string[] args)
{
  CreateWebHostBuilder(args).Build().Run();
}
```

<h6>Startup.cs</h6>
* <em>Configure</em> — how the application will respond to individual HTTP requests (you can setup pipelines which will process requests)
* <em>ConfigureServices</em> — method for configuring services that are used by your application

```
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }

            app.UseHttpsRedirection();
            app.UseMvc();
        }
```

```
public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }
```

<Level id="creating-controllers-and-services" number="3" name="Creating controllers and services" difficulty="No kidding" objectives="Write, run and test API." />

<p>I’m going to show you how we can write <strong>API</strong> using ASP.NET Core WebAPI. We will be able to get a list of users and get user by id. <a href="https://jsonplaceholder.typicode.com/">JsonPlaceholder</a> will be used for data set.</p>

<p>But first, let’s run the application we’ve just created.
You can use <code>dotnet run</code> command to start the server. 
To make sure that our API is working, we should send a request to the created by default <code>ValuesController</code>. </p>

<p>https://localhost:5001/api/values</p>

<p>You should see <code>value1, value2</code> as a response.</p>

<p>P.S. You can use Postman for testing your API. But I would recommend using a VSCode extension called <a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST Client</a>.
</p>

<h4>WebApi Controller</h4>
<p>Let’s practise a bit more and create a new controller. 
Create a new file called <em>UsersController</em> in <em>Controllers</em> folder. Add two GET methods which will return a list of users and a user by his id. Use <code>ValuesController</code> as an example.
Eventually you should have similar code:</p>
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;

namespace ASP.NET_Core_Lecture.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class UsersController : ControllerBase
    {
        // GET api/users
        [HttpGet]
        public ActionResult<IEnumerable<string>> Get()
        {
            return new string[] { "user1", "user2" };
        }

        // GET api/users/5
        [HttpGet("{id}")]
        public ActionResult<string> Get(int id)
        {
            return $"user{id}";
        }
    }
}
```
<p>Start the application and go to https://localhost:5001/api/users/ to make sure that your new controller is available.</p>

<h4>UserService</h4>

<p>Writing business logic in controllers isn’t the best idea, so it would be better if we created a separate service for this purpose.</p>

<h6>UsersController.cs</h6>
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using ASP.NET_Core_Lecture.Services;
using Microsoft.AspNetCore.Mvc;

namespace ASP.NET_Core_Lecture.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class UsersController : ControllerBase
    {
        private UsersService usersService;
        public UsersController()
        {
            usersService = new UsersService();
        }

        // GET api/users
        [HttpGet]
        public ActionResult<IEnumerable<string>> Get()
        {
            return Ok(usersService.GetUsers());
        }

        // GET api/users/5
        [HttpGet("{id}")]
        public ActionResult<string> Get(int id)
        {
            return Ok(usersService.GetUser(id));
        }
    }
}
```

<h6>UsersService.cs</h6>
```
using System.Collections.Generic;

namespace ASP.NET_Core_Lecture.Services
{
    public class UsersService
    {
        public IEnumerable<string> GetUsers()
        {
            return new string[] { "user1", "user2" };
        }

        public string GetUser(int id)
        {
            return $"user{id}";
        }
    }
}
```
<p>Run the application and test https://localhost:5001/api/users/ again to make sure everything works as before.</p>

<p>In the next step I suggest implementing <strong>remote data loading</strong> using JsonPlaceholder service.
In order to serialize response we will need to add a package that works with JSON.
Use <code>dotnet add package Newtonsoft.Json</code> command to install the package.</p>

<h6>Updated UsersController.cs</h6>
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using ASP.NET_Core_Lecture.Services;
using Microsoft.AspNetCore.Mvc;

namespace ASP.NET_Core_Lecture.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class UsersController : ControllerBase
    {
        private UsersService usersService;
        public UsersController()
        {
            usersService = new UsersService();
        }

        // GET api/values
        [HttpGet]
        public async Task<ActionResult<List<User>>> Get()
        {
            return Ok(await usersService.GetUsers());
        }

        // GET api/values/5
        [HttpGet("{id}")]
        public async Task<ActionResult<User>> Get(int id)
        {
            return Ok(await usersService.GetUser(id));
        }
    }
}
```

<h6>Updates UsersService.cs</h6>
```
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using Newtonsoft.Json;

namespace ASP.NET_Core_Lecture.Services
{
    public class UsersService
    {
        private HttpClient _client { get; set; }

        public UsersService()
        {
            _client = new HttpClient();
        }

        public async Task<List<User>> GetUsers()
        {
            var users = await _client.GetStringAsync("https://jsonplaceholder.typicode.com/users");
            return JsonConvert.DeserializeObject<List<User>>(users);
        }

        public string GetUser(int id)
        {
            return $"user{id}";
        }
    }

    public class User
    {
        public int id { get; set; }
        public string username { get; set; }
        public string email { get; set; }
        public string website { get; set; }
    }
}
```


<Level id="additional-features" number="4" name="Additional features" difficulty="I know kung-fu" objectives="Learn how to talk in .NET dialect." />

<h4>Short review of Dependency Injection (Singleton, Scoped, Transient)</h4>

<p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2">Dependency injection (DI)</a> — software design pattern, which is a technique for achieving <a href="https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#dependency-inversion">Inversion of Control (IoC)</a> between classes and their dependencies.</p>

<p>In our case UsersController depends on UsersService. 
There might be a case when JsonPlaceholder won’t response to our requests. In this case we would want to use another implementation of UsersService (use another source or provide mocked data). We would need to go through our app and change class name manually in all places where it’s used.
With DI we can do it easily in one place (ConfigureServices() in Startup.cs). Moreover, in .NET Core DI container can create instances of dependencies of dependencies. Otherwise we would need to do it manually in every service. In addition to that, .NET Core DI container takes on the responsibility of creating an instance of the dependency and disposing of it when it's no longer needed.</p>

<p>There are a few service lifetime options:</p>
* <em>Singleton</em> — services are created the first time they're requested (or when ConfigureServices is run and an instance is specified with the service registration). Every subsequent request uses the same instance.
* <em>Scoped</em> — services are created once per client request (connection).
* <em>Transient</em> — services are created each time they're requested from the service container. This lifetime works best for lightweight, stateless services.

<p>Let’s apply it for our UsersService:

Add the next code to <code>ConfigureServices() [Startup.cs]</code>
```
services.AddTransient<UsersService>();
```

And update UsersController’s constructor:</p>
```
        public UsersController(UsersService service)
        {
            _usersService = service;
        }
```

<p>Going further, we can create an interface for UsersService. It will let us switch services in one place.

Change the previous version of service registration to the next one: </p>

```
services.AddTransient<IUsersService, UsersService>();
```

<p>Update UsersController to operate with the interface (notice how we got rid of explicit class name):</p>
```
       private IUsersService _usersService;
        public UsersController(IUsersService service)
        {
            _usersService = service;
        }
```

<p>Don’t forget to inherit our UsersService from IUsersService:</p>
```
public class UsersService : IUsersService
```

<h4>Middleware</h4>
<p>Middleware is software that's assembled into an app pipeline to handle requests and responses.
Long story short: the app applies all middlewares one by one for each request.</p>

![php-fpm_nginx](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/index/_static/request-delegate-pipeline.png?view=aspnetcore-2.2)

<p>For example, if you want to log all the requests, you can add a pipeline. <em>(I use Console.WriteLine for simplicity. You can use any logging framework here.)</em>

Add the next code info Configure method [Startup.cs]:</p>

```
            app.Use(async (context, next) => 
            {
                Console.WriteLine("Started handling request");
                await next.Invoke();
                Console.WriteLine("Finished handling request");
            });
```
<p>Then start the app, send request and see the console output.</p>

<h4>Routing</h4>

<p>Routing is responsible for mapping request URIs to endpoint selectors and dispatching incoming requests to endpoints. Routes are defined in the app and configured when the app starts. A route can optionally extract values from the URL contained in the request, and these values can then be used for request processing. Basically, routing is a middleware. Using the picture above, imagine how request comes to the server, then it’s being processed by a chain of middlewares and then routing middleware matches URL to controller and method names.

In WebAPI we define route using attribute Route.</p>

```
[Route("api/[controller]")]
[ApiController]
public class UsersController : ControllerBase
```
<p>We can do the same for methods in controller.</p>

<h4>Razor pages (MVC app structure, return page from controller method, syntax)</h4>


export const metadata = {
  author: "Nikita Krasnov",
  title: "How ASP.NET Core works",
  description: "",
  keywords: ["hola", "guapa"]
}

export default Lecture;
